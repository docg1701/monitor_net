# Story 1.2: Implement SQLite Schema and Migrations

## Status
Approved

## Story
**As a** developer,
**I want** a versioned database schema with migration support,
**so that** future schema changes can be applied safely to existing installations.

## Acceptance Criteria

| # | Criteria |
|---|----------|
| AC1 | `pings` table created with columns: `id`, `timestamp`, `latency_ms`, `success`, `target` |
| AC2 | `settings` table created with columns: `key`, `value` |
| AC3 | Index created on `pings.timestamp` for query performance |
| AC4 | Migration system tracks schema version in database |
| AC5 | Migrations run automatically on app startup |
| AC6 | Migration failures are logged and don't crash the app |

## Integration Verification

| # | Verification |
|---|--------------|
| IV1 | Fresh install creates schema correctly on both platforms |
| IV2 | App upgrade with existing database applies migrations without data loss |
| IV3 | Database operations complete within acceptable time (<100ms for single inserts) |

## Tasks / Subtasks

- [ ] Task 1: Create Migration Service (AC: 4, 5, 6)
  - [ ] 1.1 Create file `netmonitor/src/app/services/migration.service.ts`
  - [ ] 1.2 Inject `DatabaseService` using `inject()` pattern
  - [ ] 1.3 Define migration interface with `version: number` and `up(): Promise<void>`
  - [ ] 1.4 Implement `getCurrentVersion(): Promise<number>` - reads from settings table
    - [ ] 1.4.1 Query: `SELECT value FROM settings WHERE key = 'schema_version'`
    - [ ] 1.4.2 Wrap SELECT in try/catch - if table doesn't exist ("no such table" error), return 0
    - [ ] 1.4.3 If row not found (empty result), return 0
    - [ ] 1.4.4 Parse and return version number from result
  - [ ] 1.5 Implement `setVersion(version: number): Promise<void>` - writes to settings table
  - [ ] 1.6 Implement `runMigrations(): Promise<void>` - executes pending migrations sequentially
  - [ ] 1.7 Add error handling with logging (use `console.error`) - must NOT throw/crash app

- [ ] Task 2: Create Version 1 Migration - Base Schema (AC: 1, 2, 3)
  - [ ] 2.1 Create file `netmonitor/src/app/services/migrations/v1-initial-schema.ts`
  - [ ] 2.2 Create `settings` table FIRST (needed to track schema version):
    ```sql
    CREATE TABLE IF NOT EXISTS settings (
      key TEXT PRIMARY KEY,
      value TEXT
    )
    ```
  - [ ] 2.3 Create `pings` table:
    ```sql
    CREATE TABLE IF NOT EXISTS pings (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      timestamp INTEGER NOT NULL,
      latency_ms REAL,
      success INTEGER NOT NULL,
      target TEXT NOT NULL
    )
    ```
  - [ ] 2.4 Create index on `pings.timestamp`:
    ```sql
    CREATE INDEX IF NOT EXISTS idx_pings_timestamp ON pings(timestamp)
    ```

- [ ] Task 3: Integrate Migrations with App Startup (AC: 5)
  - [ ] 3.1 Update `app.module.ts` to add `MigrationService` to providers (if not using `providedIn: 'root'`)
  - [ ] 3.2 Create `APP_INITIALIZER` factory that:
    - Waits for `DatabaseService.isInitialized$` to emit `true`
    - Calls `MigrationService.runMigrations()`
  - [ ] 3.3 Add provider: `{ provide: APP_INITIALIZER, useFactory: initializeMigrations, deps: [DatabaseService, MigrationService], multi: true }`
  - [ ] 3.4 Ensure initializer handles WebDatabaseService gracefully (no-op when DB unavailable)

- [ ] Task 4: Write Unit Tests for MigrationService (AC: 1-6)
  - [ ] 4.1 Create `netmonitor/src/app/services/migration.service.spec.ts`
  - [ ] 4.2 Test: `getCurrentVersion()` returns 0 when settings table is empty
  - [ ] 4.3 Test: `setVersion()` correctly stores version in settings table
  - [ ] 4.4 Test: `runMigrations()` executes migrations in order
  - [ ] 4.5 Test: `runMigrations()` skips already-applied migrations
  - [ ] 4.6 Test: Migration failure is logged but doesn't throw
  - [ ] 4.7 Test: V1 migration creates `pings` table with correct columns
  - [ ] 4.8 Test: V1 migration creates `settings` table with correct columns
  - [ ] 4.9 Test: V1 migration creates index on `pings.timestamp`
  - [ ] 4.10 Test: `getCurrentVersion()` returns 0 when settings table doesn't exist (first-run scenario)

- [ ] Task 5: Verify Regression - Existing Functionality (IV: 1, 2, 3)
  - [ ] 5.1 Run existing test suite: `npm test` - all 55 tests must pass
  - [ ] 5.2 Verify in browser: app loads without errors (WebDatabaseService no-op path)
  - [ ] 5.3 Manual verification: app startup time remains acceptable
  - [ ] 5.4 Tauri verification: Build desktop app (`npm run tauri build`), run, verify `netmonitor.db` created with tables
  - [ ] 5.5 Capacitor verification: Build Android debug APK, run on emulator, verify schema via `adb shell` or logs

## Dev Notes

### Previous Story Insights (Story 1.1)
[Source: docs/stories/1.1.create-abstract-database-service-layer.md#dev-agent-record]

- DatabaseService abstract class already exists with `init()`, `execute()`, `select()`, `close()` methods
- Three implementations in place: `TauriDatabaseService`, `CapacitorDatabaseService`, `WebDatabaseService`
- Platform detection factory in `app.module.ts` provides correct implementation
- `isInitialized$` Observable<boolean> tracks database ready state (use `filter(ready => ready)` to wait)
- WebDatabaseService is a no-op stub that sets `isInitialized$` to true immediately
- Test framework is Vitest with browser mode (Chromium via Playwright)
- Use `inject()` pattern for DI (not constructor injection)

### Source Tree - Files to Create
[Source: architecture/source-tree-and-module-organization.md, architecture/enhancement-impact-analysis.md]

```
netmonitor/src/app/services/
├── migration.service.ts         # Migration orchestrator (NEW)
├── migration.service.spec.ts    # Unit tests (NEW)
└── migrations/
    └── v1-initial-schema.ts     # Version 1 migration (NEW)
```

### Source Tree - Files to Modify
[Source: architecture/enhancement-impact-analysis.md]

```
netmonitor/src/app/
└── app.module.ts                # Add APP_INITIALIZER for migrations
```

### Data Models - Schema Definition
[Source: architecture/data-models-and-schema.md#database-tables]

**pings table:**
| Column | Type | Description |
|--------|------|-------------|
| id | INTEGER | Primary key, auto-increment |
| timestamp | INTEGER | Unix timestamp (indexed for query performance) |
| latency_ms | REAL | Latency in milliseconds (nullable for errors) |
| success | INTEGER | 1 = ok, 0 = error |
| target | TEXT | Ping destination address |

**settings table:**
| Column | Type | Description |
|--------|------|-------------|
| key | TEXT | Primary key, setting identifier |
| value | TEXT | JSON-encoded setting value |

**Index:** `CREATE INDEX idx_pings_timestamp ON pings(timestamp)`

### Migration System Design
[Source: architecture/data-models-and-schema.md#schema-integration-strategy]

- Schema version tracked in `settings` table with key `schema_version`
- Migrations are idempotent and non-destructive
- Use `CREATE TABLE IF NOT EXISTS` and `CREATE INDEX IF NOT EXISTS`
- Each migration checks current version before applying
- Failed migrations logged but don't crash app (graceful degradation)

### Service Pattern
[Source: architecture/coding-standards.md#service-pattern]

```typescript
@Injectable({
  providedIn: 'root'
})
export class MigrationService {
  private db = inject(DatabaseService);

  // Use async/await for one-shot operations
  async runMigrations(): Promise<void> {
    // Implementation
  }
}
```

### APP_INITIALIZER Pattern
[Source: Angular documentation]

```typescript
// In app.module.ts
import { APP_INITIALIZER } from '@angular/core';

export function initializeMigrations(
  db: DatabaseService,
  migrationService: MigrationService
): () => Promise<void> {
  return async () => {
    // Wait for database to be ready
    await firstValueFrom(db.isInitialized$.pipe(filter(ready => ready)));
    await migrationService.runMigrations();
  };
}

@NgModule({
  providers: [
    {
      provide: APP_INITIALIZER,
      useFactory: initializeMigrations,
      deps: [DatabaseService, MigrationService],
      multi: true
    }
  ]
})
export class AppModule {}
```

### Error Handling Requirements
[Source: architecture/coding-standards.md#code-quality-rules]

- Never swallow errors silently - always log
- Migration failures must NOT crash the app
- Use try/catch with `console.error()` for migration errors
- App must remain functional even if migrations fail (graceful degradation)

### Platform Considerations
[Source: architecture/architecture-patterns-and-conventions.md#platform-detection-pattern]

- WebDatabaseService returns empty results and resolves immediately
- Migration service should check `db.isInitialized` before running migrations
- If database is unavailable (browser mode), migrations should be a no-op

**WebDatabaseService Migration Behavior:**
- `select()` returns empty arrays → `getCurrentVersion()` returns 0 (no rows found)
- `execute()` resolves immediately (no-op) → migrations "run" but don't persist
- Schema version won't persist between sessions in browser mode
- This is acceptable for browser dev mode - no special handling needed beyond existing no-op behavior
- Migrations will re-run on each browser refresh (harmless due to `IF NOT EXISTS` clauses)

## Testing

### Test File Location
[Source: architecture/source-tree-and-module-organization.md]

- Test files co-located with source: `*.spec.ts`
- Create: `netmonitor/src/app/services/migration.service.spec.ts`

### Testing Framework
[Source: architecture/testing-strategy.md]

- **Test Runner:** Vitest (via `@angular/build:unit-test`)
- **Browser Mode:** Chromium via Playwright
- **Commands:** `npm test` or `ng test --browsers=chromium`

### Test Structure Pattern
[Source: architecture/coding-standards.md#unit-test-structure]

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { TestBed } from '@angular/core/testing';

describe('MigrationService', () => {
  let service: MigrationService;
  let mockDb: jasmine.SpyObj<DatabaseService>;

  beforeEach(() => {
    mockDb = {
      isInitialized: true,
      execute: vi.fn().mockResolvedValue(undefined),
      select: vi.fn().mockResolvedValue([]),
    } as any;

    TestBed.configureTestingModule({
      providers: [
        MigrationService,
        { provide: DatabaseService, useValue: mockDb }
      ]
    });
    service = TestBed.inject(MigrationService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});
```

### Coverage Target
[Source: architecture/testing-strategy.md]

- **Target:** 80% coverage on new services
- **Command:** `ng test --coverage`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-11 | 0.1 | Initial draft created from Epic 1 | Scrum Master |
| 2025-12-11 | 0.2 | PO validation fixes: Task 1.4 error handling, isInitialized$ type, WebDatabaseService guidance, test 4.10, verification tasks | PO (Sarah) |

---

## Dev Agent Record

### Agent Model Used
_To be filled by Dev Agent_

### File List
_To be filled by Dev Agent_

### Debug Log References
_To be filled by Dev Agent_

### Completion Notes
_To be filled by Dev Agent_

---

## QA Results
_To be filled by QA Agent_
