# Story 1.5: Add Data Retention and Cleanup

## Status
**Approved**

## Story
**As a** user,
**I want** old monitoring data automatically cleaned up,
**so that** the database doesn't grow indefinitely and slow down my device.

## Acceptance Criteria

| # | Criteria |
|---|----------|
| AC1 | Default retention period is 30 days |
| AC2 | Cleanup runs on app startup (after migrations) |
| AC3 | Cleanup deletes pings older than retention period |
| AC4 | Cleanup is logged with count of deleted records |
| AC5 | Retention period will be configurable in Settings (future story) |

## Integration Verification

| # | Verification |
|---|--------------|
| IV1 | Recent data (<30 days) is preserved after cleanup |
| IV2 | Cleanup completes within reasonable time (<2s for 100k records) |
| IV3 | App remains responsive during cleanup operation |

## Tasks / Subtasks

- [ ] Task 1: Add Cleanup Method to PingRepository (AC: 1, 3, 4)
  - [ ] 1.1 Add constant `DEFAULT_RETENTION_DAYS = 30` to PingRepository
  - [ ] 1.2 Implement `deleteOldPings(retentionDays?: number): Promise<number>` method
    - [ ] 1.2.1 Calculate cutoff timestamp: `Date.now() - (retentionDays * 24 * 60 * 60 * 1000)`
    - [ ] 1.2.2 Check `db.isInitialized` first - return 0 if false
    - [ ] 1.2.3 Execute DELETE with parameterized SQL: `DELETE FROM pings WHERE timestamp < ?`
    - [ ] 1.2.4 Query count of deleted rows (SQLite returns this via changes)
    - [ ] 1.2.5 Log result: `console.log('CleanupService: Deleted X old ping records')`
    - [ ] 1.2.6 Wrap in try/catch - log errors but don't throw
  - [ ] 1.3 Add JSDoc documentation for the method

- [ ] Task 2: Create CleanupService (AC: 2, 4)
  - [ ] 2.1 Create file `netmonitor/src/app/services/cleanup.service.ts`
  - [ ] 2.2 Inject `PingRepository` using `inject()` pattern
  - [ ] 2.3 Implement `runCleanup(): Promise<void>` method
    - [ ] 2.3.1 Log start: `console.log('CleanupService: Starting data retention cleanup...')`
    - [ ] 2.3.2 Call `pingRepository.deleteOldPings()` (note: repository already logs deletion count)
    - [ ] 2.3.3 Log completion: `console.log('CleanupService: Cleanup complete')`
    - [ ] 2.3.4 Handle errors gracefully (log, don't crash)
  - [ ] 2.4 Add JSDoc documentation

- [ ] Task 3: Integrate CleanupService into APP_INITIALIZER (AC: 2)
  - [ ] 3.1 Add import: `import { CleanupService } from './services/cleanup.service';` to `app.module.ts`
  - [ ] 3.2 Modify `initializeMigrations()` function signature to include `CleanupService` parameter
  - [ ] 3.3 Add `CleanupService` to APP_INITIALIZER deps array
  - [ ] 3.4 Call `cleanupService.runCleanup()` after `migrationService.runMigrations()`
  - [ ] 3.5 Ensure cleanup errors don't block app startup (wrap in try/catch)

- [ ] Task 4: Implement Delete Count Return from DatabaseService (AC: 4)
  - [ ] 4.1 Note: SQLite `DELETE` returns number of affected rows
  - [ ] 4.2 For TauriDatabaseService: `@tauri-apps/plugin-sql` execute returns `{ rowsAffected: number }`
  - [ ] 4.3 For CapacitorDatabaseService: `@capacitor-community/sqlite` execute returns `{ changes: { changes: number } }`
  - [ ] 4.4 Add method `executeWithCount(sql: string, params?: unknown[]): Promise<number>` to DatabaseService abstract class
  - [ ] 4.5 Implement in TauriDatabaseService, CapacitorDatabaseService, WebDatabaseService

- [ ] Task 5: Write Unit Tests for PingRepository.deleteOldPings() (AC: 1, 3, 4)
  - [ ] 5.1 Update `netmonitor/src/app/services/ping.repository.spec.ts`
  - [ ] 5.2 Test: `deleteOldPings()` uses correct cutoff timestamp calculation (30 days default)
  - [ ] 5.3 Test: `deleteOldPings(7)` uses 7-day cutoff when parameter provided
  - [ ] 5.4 Test: `deleteOldPings()` returns 0 when database not initialized
  - [ ] 5.5 Test: `deleteOldPings()` returns count of deleted records
  - [ ] 5.6 Test: `deleteOldPings()` catches errors and returns 0 (doesn't throw)
  - [ ] 5.7 Test: `deleteOldPings()` logs deletion count

- [ ] Task 6: Write Unit Tests for CleanupService (AC: 2, 4)
  - [ ] 6.1 Create `netmonitor/src/app/services/cleanup.service.spec.ts`
  - [ ] 6.2 Test: `runCleanup()` calls `pingRepository.deleteOldPings()`
  - [ ] 6.3 Test: `runCleanup()` logs start and completion messages
  - [ ] 6.4 Test: `runCleanup()` handles errors gracefully (doesn't throw)

- [ ] Task 7: Verify Regression and Integration (IV: 1, 2, 3)
  - [ ] 7.1 Run existing test suite: `npm test` - all tests pass
  - [ ] 7.2 Manual verification: Run Tauri app with existing data
    - [ ] 7.2.1 Insert test data older than 30 days using SQL
    - [ ] 7.2.2 Restart app
    - [ ] 7.2.3 Verify old data is deleted, recent data preserved (IV1)
  - [ ] 7.3 Performance verification: Test with 100k+ records (IV2)
  - [ ] 7.4 Startup verification: App remains responsive during cleanup (IV3)
  - [ ] 7.5 Lint check: `npm run lint` passes

## Dev Notes

### Previous Story Insights (Story 1.4)
[Source: docs/stories/1.4.implement-tab-based-navigation-structure.md#dev-agent-record]

- MonitorService uses fire-and-forget pattern for persistence (non-blocking)
- PingRepository handles errors internally, monitoring continues regardless
- Database initialization happens via `APP_INITIALIZER` in `app.module.ts`
- WebDatabaseService (browser mode) is a no-op - all methods resolve immediately
- Platform detection uses `isTauri()` from `@tauri-apps/api/core`

### App Initialization Flow
[Source: netmonitor/src/app/app.module.ts]

Current initialization sequence in `initializeMigrations()`:
```typescript
export function initializeMigrations(
  db: DatabaseService,
  migrationService: MigrationService
): () => Promise<void> {
  return async () => {
    await db.init();
    // Wait for isInitialized$ if needed
    migrationService.registerMigration(createV1Migration(db));
    await migrationService.runMigrations();
    // >>> ADD CLEANUP HERE <<<
  };
}
```

**Modification Required:** Add CleanupService to deps and call after migrations:
```typescript
export function initializeMigrations(
  db: DatabaseService,
  migrationService: MigrationService,
  cleanupService: CleanupService  // NEW
): () => Promise<void> {
  return async () => {
    await db.init();
    migrationService.registerMigration(createV1Migration(db));
    await migrationService.runMigrations();
    await cleanupService.runCleanup();  // NEW - after migrations
  };
}
```

### DatabaseService API Reference
[Source: netmonitor/src/app/services/database.service.ts]

```typescript
abstract class DatabaseService {
  readonly isInitialized$: Observable<boolean>;
  get isInitialized(): boolean;

  abstract init(): Promise<void>;
  abstract execute(sql: string, params?: unknown[]): Promise<void>;
  abstract select<T>(sql: string, params?: unknown[]): Promise<T[]>;
  abstract close(): Promise<void>;
}
```

**Note:** Current `execute()` returns `void`. Need to add `executeWithCount()` to return affected row count for cleanup logging (AC4).

### Tauri SQL Plugin - Execute Response
[Source: @tauri-apps/plugin-sql documentation]

```typescript
// Execute returns QueryResult with rowsAffected
const result = await db.execute('DELETE FROM pings WHERE timestamp < ?', [cutoff]);
// result = { rowsAffected: 150, lastInsertId: 0 }
```

### Capacitor SQLite Plugin - Execute Response
[Source: @capacitor-community/sqlite documentation]

```typescript
// Execute returns changes object
const result = await db.run('DELETE FROM pings WHERE timestamp < ?', [cutoff]);
// result.changes = { changes: 150, lastId: -1 }
```

### Data Models - Pings Table Schema
[Source: architecture/data-models-and-schema.md]

```sql
CREATE TABLE pings (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  timestamp INTEGER NOT NULL,  -- Unix timestamp in milliseconds
  latency_ms REAL,
  success INTEGER NOT NULL,
  target TEXT NOT NULL
);
CREATE INDEX idx_pings_timestamp ON pings(timestamp);
```

**Delete Query:**
```sql
DELETE FROM pings WHERE timestamp < ?
-- Parameter: cutoff timestamp in milliseconds
```

### Retention Calculation
[Source: AC1 - 30 day default]

```typescript
const DEFAULT_RETENTION_DAYS = 30;
const MS_PER_DAY = 24 * 60 * 60 * 1000;
const cutoffTimestamp = Date.now() - (retentionDays * MS_PER_DAY);
```

### Error Handling Pattern
[Source: architecture/coding-standards.md, ping.repository.ts]

Follow the same pattern as `PingRepository.savePing()`:
```typescript
async deleteOldPings(retentionDays: number = DEFAULT_RETENTION_DAYS): Promise<number> {
  if (!this.db.isInitialized) {
    return 0;
  }

  try {
    const cutoff = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);
    const count = await this.db.executeWithCount(
      'DELETE FROM pings WHERE timestamp < ?',
      [cutoff]
    );
    console.log(`PingRepository: Deleted ${count} old ping records`);
    return count;
  } catch (err) {
    console.error('Failed to delete old pings:', err);
    return 0;
  }
}
```

### Source Tree - Files to Create
[Source: architecture/source-tree-and-module-organization.md]

```
netmonitor/src/app/services/
├── cleanup.service.ts           # Cleanup orchestration service (NEW)
└── cleanup.service.spec.ts      # Unit tests (NEW)
```

### Source Tree - Files to Modify
[Source: architecture/enhancement-impact-analysis.md]

```
netmonitor/src/app/
├── app.module.ts                    # Add CleanupService to APP_INITIALIZER
└── services/
    ├── database.service.ts          # Add executeWithCount() abstract method
    ├── tauri-database.service.ts    # Implement executeWithCount()
    ├── capacitor-database.service.ts # Implement executeWithCount()
    ├── web-database.service.ts      # Implement executeWithCount() (return 0)
    ├── ping.repository.ts           # Add deleteOldPings() method
    └── ping.repository.spec.ts      # Add tests for deleteOldPings()
```

### Settings Table - Future Configuration (AC5)
[Source: architecture/data-models-and-schema.md]

The `settings` table exists with columns: `key` (TEXT PK), `value` (TEXT).

Future story will allow user to configure retention via Settings page:
```sql
-- Store custom retention (JSON encoded)
INSERT OR REPLACE INTO settings (key, value) VALUES ('retention_days', '7');
-- Read retention
SELECT value FROM settings WHERE key = 'retention_days';
```

**For this story:** Use hardcoded default of 30 days. Do NOT read from settings table yet.

## Testing

### Test File Location
[Source: architecture/source-tree-and-module-organization.md]

- Test files co-located with source: `*.spec.ts`
- Create: `netmonitor/src/app/services/cleanup.service.spec.ts`
- Update: `netmonitor/src/app/services/ping.repository.spec.ts`

### Testing Framework
[Source: architecture/testing-strategy.md]

- **Test Runner:** Vitest (via `@angular/build:unit-test`)
- **Browser Mode:** Chromium via Playwright
- **Commands:** `npm test` or `ng test --browsers=chromium`

### Test Structure Pattern
[Source: architecture/coding-standards.md#unit-test-structure]

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { TestBed } from '@angular/core/testing';
import { PingRepository } from './ping.repository';
import { DatabaseService } from './database.service';

describe('PingRepository.deleteOldPings', () => {
  let repository: PingRepository;
  let mockDb: {
    isInitialized: boolean;
    executeWithCount: ReturnType<typeof vi.fn>;
  };

  beforeEach(() => {
    mockDb = {
      isInitialized: true,
      executeWithCount: vi.fn().mockResolvedValue(42),
    };

    TestBed.configureTestingModule({
      providers: [
        PingRepository,
        { provide: DatabaseService, useValue: mockDb }
      ]
    });
    repository = TestBed.inject(PingRepository);
  });

  it('should delete pings older than 30 days by default', async () => {
    const now = Date.now();
    vi.spyOn(Date, 'now').mockReturnValue(now);

    await repository.deleteOldPings();

    const expectedCutoff = now - (30 * 24 * 60 * 60 * 1000);
    expect(mockDb.executeWithCount).toHaveBeenCalledWith(
      'DELETE FROM pings WHERE timestamp < ?',
      [expectedCutoff]
    );
  });
});
```

### Mocking CleanupService for app.module Tests

```typescript
let mockCleanupService: { runCleanup: ReturnType<typeof vi.fn> };

beforeEach(() => {
  mockCleanupService = {
    runCleanup: vi.fn().mockResolvedValue(undefined)
  };

  TestBed.configureTestingModule({
    providers: [
      { provide: CleanupService, useValue: mockCleanupService }
    ]
  });
});
```

### Coverage Target
[Source: architecture/testing-strategy.md]

- **Target:** 80% coverage on new services
- **Command:** `ng test --coverage`

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-17 | 0.1 | Initial draft created from Epic 1 | Scrum Master |

---

## Dev Agent Record

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References
*To be filled by Dev Agent*

### Completion Notes
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

---

## QA Results
*To be filled by QA Agent*
